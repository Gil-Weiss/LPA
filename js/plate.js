//Contains all information for a lpf file
function Plate(form) {
    //The LPF file
    var LPF;

    //Call parsePlate when the object is initialized
    parseInputs(this,form);
    //Parses the entirity of the webform data into a plate object
    //Returns a plate object
    function parseInputs(plate,form) {
        plate.rows = form.find("#rows").val();
        plate.cols = form.find("#columns").val();
        plate.channelNum=form.find("#LEDnum").val();
        plate.totalTime = Math.floor(form.find("#length").val() * 60 * 1000); // in ms
        plate.timeStep = form.find("#timestep").val() * 1000; // in ms
        plate.randomized = form.find("#randomized").is(':checked');
        plate.offOnFinish = form.find("#offSwitch").is(':checked');
        //A list of all wellArrangements contained on this plate
        plate.wellArrangements=[];
        form.find(".wGroup").not(".template").each(function( index, wellArrangementForm) {
            plate.wellArrangements.push(new WellArrangement($(wellArrangementForm,plate.channelNum)));
            });
  
        console.log(plate);
    }
    //creates an LPFfile
    function createLPF() {
        
    }
    //Multiple waveform groupsthat are spread over a set of well specifications
    function WellArrangement(form,channelNum) {
        //Call Parse inputs when the object is initialized
        parseInputs(this,form);
        //Parses the entirity of the data in a waveform group section of the webpage
        //returns a wellArrangenment
        function parseInputs(wellArrangement,form) {
            wellArrangement.samples = parseInt(form.find("input.samples").val());
            wellArrangement.replicates = parseInt(form.find("input.replicates").val());
            wellArrangement.startTime = parseInt(form.find("input.startTime").val());
            wellArrangement.waveformInputs=[];
            form.find(".func").not(".template").each(function( index, waveform) {
                var newWaveform;
                waveform = $(waveform);
                if (waveform.hasClass("const")) {
                    newWaveform = new constInput(waveform);
                }else if (waveform.hasClass("step")) {
                    newWaveform = new stepInput(waveform);
                }else if (waveform.hasClass("sine")) {
                    newWaveform = new sineInput(waveform);
                }else if (waveform.hasClass("arb")) {
                    newWaveform = new arbInput(waveform);
                }
                wellArrangement.waveformInputs.push(newWaveform);
            });
            //Create waveform groups, crazy recursion is needed to create all permuatations of
            //input forms which could have multiple waveforms
            wellArrangement.waveformGroups=[new waveformGroup(channelNum)];
            waveformParsing(0,wellArrangement.waveformGroups[0]);
            function waveformParsing(inputIndex,waveformGroup) {
                //In case this starts out with waveformInputs of length zero
                 if (inputIndex>=wellArrangement.waveformInputs.length) {
                    return;
                 }
                //Loops through the group of waveforms generated by a single input
                console.log(wellArrangement);
                var waveforms = wellArrangement.waveformInputs[inputIndex].generateWaveforms();
                console.log(waveforms);
                for (waveformIndex=0; waveformIndex<waveforms.length;waveformIndex++) {
                    //If this isn't the first waveform generated from the single input duplicate the waveform group
                    if (waveformIndex!=0) {
                        waveformGroup=waveformGroup.copy();
                        wellArrangement.waveformGroups.push(waveformGroup)
                    }
                    //Join current waveform onto waveformGroup
                    //if at end of waveform inputs append to waveformGroups
                    if (inputIndex+1>=wellArrangement.waveformInputs.length) {
                        waveformGroup.addWaveform(waveforms[waveformIndex],waveforms[waveformIndex].channel);
                        return;
                    }
                    waveformParsing(inputIndex+1,waveformGroup);
                }
            }
            //contains the inputs associated a constant input in the webform
            function constInput(form) {
                this.channel = parseInt(form.find("select[class=funcWavelength]")[0].selectedIndex);
                this.amplitudes = form.find("input.ints").val();
                this.amplitudes = JSON.parse("[" + this.amplitudes + "]");
                this.amplitudes = numeric.round(this.amplitudes); // Make sure all ints are whole numbers
                //Gives the number of different waveforms that this input will create
                this.getNumWaveforms = function(){
                    return amplitudes.length;
                }
                //returns a list of waveforms associated with this constant input
                this.generateWaveforms = function() {
                    return [function(time){}];
                }
            }
            //contains the inputs associated a step input in the webform
            function stepInput(form) {
                this.channel = parseInt(form.find("select[class=funcWavelength]")[0].selectedIndex);
                this.amplitudes = form.find("input.amplitudes").val();
                this.amplitudes = JSON.parse("[" + this.amplitudes + "]");
                this.amplitudes = numeric.round(this.amplitudes); // Make sure all amps are whole numbers
                this.offset = parseInt(form.find("input.offset").val()); // GS
                this.stepTime = Math.floor(parseFloat(form.find("input.stepTime").val()) * 60 * 1000); // ms
                //Gives the number of different waveforms that this input will create
                this.getNumWaveforms = function(){
                    return amplitudes.length;
                }
                //returns a list of waveforms associated with this input
                this.generateWaveforms = function() {
                    return [function(time){}];
                }
            }
            //contains the inputs associated a sine input in the webform
            function sineInput(form) {
                this.channel = parseInt(form.find("select[class=funcWavelength]")[0].selectedIndex);
                this.amplitude = parseInt(form.find("input.amplitude").val()); // GS
                this.period = parseFloat(form.find("input.period").val()) * 60 * 1000; // ms
                this.phase = parseFloat(form.find("input.phase").val()) * 60 * 1000; // ms
                this.offset = parseInt(form.find("input.offset").val()); // GS
                //returns the waveform associated with this input
                this.generateWaveforms = function() {
                    return [function(time){}];
                }
            }
            //contains the inputs associated a arb input in the webform
            function arbInput (form) {
                this.channel = parseInt(form.find("select[class=funcWavelength]")[0].selectedIndex);
                //returns the waveform associated with this input
                this.generateWaveforms = function() {
                    return [function(time){}];
                }
            }
        }
        //Gets the intensity of an internal well number, and a channel at a given time
        this.getIntensity = function(wellNum,channel,time) {
            
        }
        //returns the total number of wells in this wellArrangement
        this.getWellTotal = function() {
            //return length of waveformGroup * timepoints
        }
        //a grouping of waveform objects
        function waveformGroup(channelNum) {
            //An array of the waveforms contained in this group, where the index is the channel number.
            this.waveforms = [channelNum];
            //Gets the intensity of a channel at a given time
            this.getIntensity = function(channel,time) {
                return waveforms[channel](time);
            }
            //adds a waveform to a given channel
            this.addWaveform = function(waveform,channel) {
                this.waveforms[channel]=waveform;
            }
            this.copy = function(){
                new newWaveformGroup;
                newWaveformGroup.waveforms=this.waveforms.slice();
                return newWaveformGroup;
            }
        }
    }
}